Ανδρέας-Θεολόγος Σπανόπουλος 
ΑΜ: 1115201700146

Δομή προγράμματος:

	Όλα τα αντικείμενα έχουν υλοποιηθεί με κλάσεις. Κάθε ζώο και φυτό έχει τη δική του κλάση (η οποία προφανώς κληρονομεί από άλλες).
	Έχω προσθέσει ορισμένα data members για δική μου διευκόλυνση (γίνεται αναφορά με σχόλια).
	Η main() είναι απλή, δεν παίρνει παράμετρους. Η main() βρίσκεται στο Simulation.cpp


Λειτουργικότητα προγράμματος:

	Το πρόγραμμα ακολουθεί (λολ) τις προδιαγραφές της εκφώνησης. Ξεκινάμε δημιουργώντας το Οικοσύστημα, μετά το πλέγμα. Έπειτα
	βάζουμε ποτάμι, λίμνη, λόφους και πεδιάδα. Έπειτα τοποθετούμε φυτά και ενήλικα ζώα (το πλήθος του κάθε ζώου που θα τοποθετηθεί 
	έχει δωθεί από το χρήστη πριν). Μετά καλείται η Ecosystem::RunEcosystem(), η οποία τρέχει την προσομοίωση για προκαθορισμένο πλήθος 
	ημερών που έχει δωθεί από το χρήστη. Εκτυπώνονται μηνύματα όταν πρέπει (Ecosystem::PrintSystem()). Κάθε μέρα οι συναρτήσεις 
	AnimalMovement() και AnimalEating() καλούνται 24 φορές. Τα ζώα κινούνται αριθμό tiles: rand() % speed, 1 tile κάθε φορά προς
	τυχαία κατεύθυνση. Κάθε tile περίεχει μια λίστα με τα ζώα που βρίσκονται πάνω σε αυτό. Συνεπώς καλούμε για κάθε tile την
	AnimalEating. Τα φυτοφάγα τρώνε το φυτό (αν υπάρχει και αν το τρώνε), και το σαρκοφάγα σαρώνουν τη λίστα με τα ζώα μέχρι
	να βρεθεί κάποιο ζώο που να μπορούν να νικήσουν σε μάχη. Αυτά γίνονται μόνο όταν τα ζώα πεινάνε. Οι λειτουργίες Grow() και
	Breed() λαμβάνουν τόπο στην Terrain::DailyReset(), με την συνάρτηση all_animals->set_stats(). Η συνάρτηση αυτή φροντίζει 
	πρακτικά για τα πάντα. Τους μετρητές ζώων, να τους βάζει/βγάζει από χειμερία νάρκη, την Grow(), κλπ. Στην DailyReset() έπειτα
	λαμβάνουν τόπο οι Breed(), δλδ από σύμβαση τα ζώα γενάνε στην αρχή της ημέρας. Έπειτα τσεκάρουμε ποια ζώα έχουν λιμοκτονήσει,
	και τα βγάζουμε από κάθε tile ξεχωριστά, και από την λίστα με όλα τα ζώα, List* all_animals (η οποία είναι Data member του 
	Ecosystem). Επίσης μια άλλη σχεδιαστική επιλογή είναι πως δεν χρησιμοποιώ καθόλου τη μεταβλητή neededFood στα σαρκοφάγα, γιατί
	σύμφωνα με την εφκώνηση, δεν χρειάζεται. Τα άλλα πάνω κάτω είναι όπως τα ζητάει η εκφώνηση. Γενικά για εισόδους του στυλ:
	Terrain Size: 30, Plants: 100 200 150 100 150 και Animals: 300 350 200 300 100 150 100, το πρόγραμμα θα αργήσει κάποια δευτερόλεπτα,
	αλλά θα τρέξει μετά. Αυτό οφείλεται στο γεγονός πως κάποιες λειτουργίες που θα μπορούσαν να υλοποιηθούν (με παραπάνω κώδικα) σε
	O(n^2) έχουν υλοποιηθεί σε O(n^3). Γενικά θα το άλλαζα, αλλά αυτή τη στιγμή που γράφω το README η ώρα είναι 22.58 και η προθεσμία
	λήγει σε 1 ώρα.



ΥΓ. Ότι μνήμη δεσμεύεται, αποδεσμέυται στο τέλος (παρόλο που το valgrind βγάζει 2-3 mismatched frees που δεν καταλαβαίνω..).

ΥΓ2. Έχω υλοποιήσει μόνος την εργασία.

ΥΓ3. Μου έβγαζε κάτι segm στην list_destroy() (η οποία καλείται από την ~List()), αλλά νομίζω το έφτιαξα.
Αν ξαναβγάλει, πιθανότατα εκεί να πηγαίνει κάτι στραβά. 



Για την μεταγλώττιση του προγράμματος, απλά δώστε την εντολή make στο terminal.
Για το τρέξιμο, δώστη την εντολή ./myprog, και έπειτα θα κατευθυνθείτε από τα μηνύματα εξόδου.
Για την διαγραφή των αντικείμενων και του εκτελέσιμου αρχείου, δώστε την εντολή make clean.
 
Ο κώδικας υλοποιήθηκε στον κειμενογράφο atom.
Αναπτύχθηκε σε g++ σε linux. 
Έχουν προστεθεί σχόλια σε διάφορα σημεία για να γίνει πιο εύκολη η καταννόηση του κώδικα (λολ).